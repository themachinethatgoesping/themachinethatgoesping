"""EM3000 (kongsberg .all / .wcd) file data container classes"""
from __future__ import annotations
import themachinethatgoesping.echosounders.em3000.filedatacontainers
import typing
import themachinethatgoesping.echosounders.em3000
import themachinethatgoesping.echosounders.em3000.datagrams
import themachinethatgoesping.tools.pyhelper

__all__ = [
    "EM3000DatagramContainer_ExtraDetections",
    "EM3000DatagramContainer_ExtraDetections_mapped",
    "EM3000DatagramContainer_Header",
    "EM3000DatagramContainer_Header_mapped",
    "EM3000DatagramContainer_QualityFactorDatagram",
    "EM3000DatagramContainer_QualityFactorDatagram_mapped",
    "EM3000DatagramContainer_RawRangeAndAngle",
    "EM3000DatagramContainer_RawRangeAndAngle_mapped",
    "EM3000DatagramContainer_SeabedImageData",
    "EM3000DatagramContainer_SeabedImageData_mapped",
    "EM3000DatagramContainer_Unknown",
    "EM3000DatagramContainer_Unknown_mapped",
    "EM3000DatagramContainer_Variant",
    "EM3000DatagramContainer_Variant_mapped",
    "EM3000DatagramContainer_WaterColumnDatagram",
    "EM3000DatagramContainer_WaterColumnDatagram_mapped",
    "EM3000DatagramContainer_XYZDatagram",
    "EM3000DatagramContainer_XYZDatagram_mapped"
]


class EM3000DatagramContainer_ExtraDetections():
    @typing.overload
    def __call__(self, datagram_identifier: themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier) -> EM3000DatagramContainer_ExtraDetections: ...
    @typing.overload
    def __call__(self, datagram_identifiers: typing.List[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier]) -> EM3000DatagramContainer_ExtraDetections: ...
    def __copy__(self) -> EM3000DatagramContainer_ExtraDetections: ...
    def __deepcopy__(self, arg0: dict) -> EM3000DatagramContainer_ExtraDetections: ...
    @typing.overload
    def __getitem__(self, index: int) -> themachinethatgoesping.echosounders.em3000.datagrams.ExtraDetections: ...
    @typing.overload
    def __getitem__(self, slice: themachinethatgoesping.tools.pyhelper.PyIndexerSlice) -> EM3000DatagramContainer_ExtraDetections: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: 
        """
        Return object information as string
        """
    def __reversed__(self) -> EM3000DatagramContainer_ExtraDetections: ...
    def __str__(self) -> str: 
        """
        Return object information as string
        """
    def break_by_time_diff(self, max_time_diff_seconds: float) -> typing.List[EM3000DatagramContainer_ExtraDetections]: ...
    def copy(self) -> EM3000DatagramContainer_ExtraDetections: 
        """
        return a copy using the c++ default copy constructor
        """
    def count_datagrams_per_type(self) -> typing.Dict[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier, int]: ...
    def find_datagram_types(self) -> typing.List[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier]: ...
    def get_sorted_by_time(self) -> EM3000DatagramContainer_ExtraDetections: ...
    def info_string(self, float_precision: int = 2) -> str: 
        """
        Return object information as string
        """
    def print(self, float_precision: int = 2) -> None: 
        """
        Print object information
        """
    def size(self) -> int: ...
    pass
class EM3000DatagramContainer_ExtraDetections_mapped():
    @typing.overload
    def __call__(self, datagram_identifier: themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier) -> EM3000DatagramContainer_ExtraDetections_mapped: ...
    @typing.overload
    def __call__(self, datagram_identifiers: typing.List[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier]) -> EM3000DatagramContainer_ExtraDetections_mapped: ...
    def __copy__(self) -> EM3000DatagramContainer_ExtraDetections_mapped: ...
    def __deepcopy__(self, arg0: dict) -> EM3000DatagramContainer_ExtraDetections_mapped: ...
    @typing.overload
    def __getitem__(self, index: int) -> themachinethatgoesping.echosounders.em3000.datagrams.ExtraDetections: ...
    @typing.overload
    def __getitem__(self, slice: themachinethatgoesping.tools.pyhelper.PyIndexerSlice) -> EM3000DatagramContainer_ExtraDetections_mapped: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: 
        """
        Return object information as string
        """
    def __reversed__(self) -> EM3000DatagramContainer_ExtraDetections_mapped: ...
    def __str__(self) -> str: 
        """
        Return object information as string
        """
    def break_by_time_diff(self, max_time_diff_seconds: float) -> typing.List[EM3000DatagramContainer_ExtraDetections_mapped]: ...
    def copy(self) -> EM3000DatagramContainer_ExtraDetections_mapped: 
        """
        return a copy using the c++ default copy constructor
        """
    def count_datagrams_per_type(self) -> typing.Dict[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier, int]: ...
    def find_datagram_types(self) -> typing.List[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier]: ...
    def get_sorted_by_time(self) -> EM3000DatagramContainer_ExtraDetections_mapped: ...
    def info_string(self, float_precision: int = 2) -> str: 
        """
        Return object information as string
        """
    def print(self, float_precision: int = 2) -> None: 
        """
        Print object information
        """
    def size(self) -> int: ...
    pass
class EM3000DatagramContainer_Header():
    @typing.overload
    def __call__(self, datagram_identifier: themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier) -> EM3000DatagramContainer_Header: ...
    @typing.overload
    def __call__(self, datagram_identifiers: typing.List[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier]) -> EM3000DatagramContainer_Header: ...
    def __copy__(self) -> EM3000DatagramContainer_Header: ...
    def __deepcopy__(self, arg0: dict) -> EM3000DatagramContainer_Header: ...
    @typing.overload
    def __getitem__(self, index: int) -> themachinethatgoesping.echosounders.em3000.datagrams.EM3000Datagram: ...
    @typing.overload
    def __getitem__(self, slice: themachinethatgoesping.tools.pyhelper.PyIndexerSlice) -> EM3000DatagramContainer_Header: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: 
        """
        Return object information as string
        """
    def __reversed__(self) -> EM3000DatagramContainer_Header: ...
    def __str__(self) -> str: 
        """
        Return object information as string
        """
    def break_by_time_diff(self, max_time_diff_seconds: float) -> typing.List[EM3000DatagramContainer_Header]: ...
    def copy(self) -> EM3000DatagramContainer_Header: 
        """
        return a copy using the c++ default copy constructor
        """
    def count_datagrams_per_type(self) -> typing.Dict[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier, int]: ...
    def find_datagram_types(self) -> typing.List[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier]: ...
    def get_sorted_by_time(self) -> EM3000DatagramContainer_Header: ...
    def info_string(self, float_precision: int = 2) -> str: 
        """
        Return object information as string
        """
    def print(self, float_precision: int = 2) -> None: 
        """
        Print object information
        """
    def size(self) -> int: ...
    pass
class EM3000DatagramContainer_Header_mapped():
    @typing.overload
    def __call__(self, datagram_identifier: themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier) -> EM3000DatagramContainer_Header_mapped: ...
    @typing.overload
    def __call__(self, datagram_identifiers: typing.List[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier]) -> EM3000DatagramContainer_Header_mapped: ...
    def __copy__(self) -> EM3000DatagramContainer_Header_mapped: ...
    def __deepcopy__(self, arg0: dict) -> EM3000DatagramContainer_Header_mapped: ...
    @typing.overload
    def __getitem__(self, index: int) -> themachinethatgoesping.echosounders.em3000.datagrams.EM3000Datagram: ...
    @typing.overload
    def __getitem__(self, slice: themachinethatgoesping.tools.pyhelper.PyIndexerSlice) -> EM3000DatagramContainer_Header_mapped: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: 
        """
        Return object information as string
        """
    def __reversed__(self) -> EM3000DatagramContainer_Header_mapped: ...
    def __str__(self) -> str: 
        """
        Return object information as string
        """
    def break_by_time_diff(self, max_time_diff_seconds: float) -> typing.List[EM3000DatagramContainer_Header_mapped]: ...
    def copy(self) -> EM3000DatagramContainer_Header_mapped: 
        """
        return a copy using the c++ default copy constructor
        """
    def count_datagrams_per_type(self) -> typing.Dict[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier, int]: ...
    def find_datagram_types(self) -> typing.List[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier]: ...
    def get_sorted_by_time(self) -> EM3000DatagramContainer_Header_mapped: ...
    def info_string(self, float_precision: int = 2) -> str: 
        """
        Return object information as string
        """
    def print(self, float_precision: int = 2) -> None: 
        """
        Print object information
        """
    def size(self) -> int: ...
    pass
class EM3000DatagramContainer_QualityFactorDatagram():
    @typing.overload
    def __call__(self, datagram_identifier: themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier) -> EM3000DatagramContainer_QualityFactorDatagram: ...
    @typing.overload
    def __call__(self, datagram_identifiers: typing.List[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier]) -> EM3000DatagramContainer_QualityFactorDatagram: ...
    def __copy__(self) -> EM3000DatagramContainer_QualityFactorDatagram: ...
    def __deepcopy__(self, arg0: dict) -> EM3000DatagramContainer_QualityFactorDatagram: ...
    @typing.overload
    def __getitem__(self, index: int) -> themachinethatgoesping.echosounders.em3000.datagrams.QualityFactorDatagram: ...
    @typing.overload
    def __getitem__(self, slice: themachinethatgoesping.tools.pyhelper.PyIndexerSlice) -> EM3000DatagramContainer_QualityFactorDatagram: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: 
        """
        Return object information as string
        """
    def __reversed__(self) -> EM3000DatagramContainer_QualityFactorDatagram: ...
    def __str__(self) -> str: 
        """
        Return object information as string
        """
    def break_by_time_diff(self, max_time_diff_seconds: float) -> typing.List[EM3000DatagramContainer_QualityFactorDatagram]: ...
    def copy(self) -> EM3000DatagramContainer_QualityFactorDatagram: 
        """
        return a copy using the c++ default copy constructor
        """
    def count_datagrams_per_type(self) -> typing.Dict[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier, int]: ...
    def find_datagram_types(self) -> typing.List[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier]: ...
    def get_sorted_by_time(self) -> EM3000DatagramContainer_QualityFactorDatagram: ...
    def info_string(self, float_precision: int = 2) -> str: 
        """
        Return object information as string
        """
    def print(self, float_precision: int = 2) -> None: 
        """
        Print object information
        """
    def size(self) -> int: ...
    pass
class EM3000DatagramContainer_QualityFactorDatagram_mapped():
    @typing.overload
    def __call__(self, datagram_identifier: themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier) -> EM3000DatagramContainer_QualityFactorDatagram_mapped: ...
    @typing.overload
    def __call__(self, datagram_identifiers: typing.List[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier]) -> EM3000DatagramContainer_QualityFactorDatagram_mapped: ...
    def __copy__(self) -> EM3000DatagramContainer_QualityFactorDatagram_mapped: ...
    def __deepcopy__(self, arg0: dict) -> EM3000DatagramContainer_QualityFactorDatagram_mapped: ...
    @typing.overload
    def __getitem__(self, index: int) -> themachinethatgoesping.echosounders.em3000.datagrams.QualityFactorDatagram: ...
    @typing.overload
    def __getitem__(self, slice: themachinethatgoesping.tools.pyhelper.PyIndexerSlice) -> EM3000DatagramContainer_QualityFactorDatagram_mapped: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: 
        """
        Return object information as string
        """
    def __reversed__(self) -> EM3000DatagramContainer_QualityFactorDatagram_mapped: ...
    def __str__(self) -> str: 
        """
        Return object information as string
        """
    def break_by_time_diff(self, max_time_diff_seconds: float) -> typing.List[EM3000DatagramContainer_QualityFactorDatagram_mapped]: ...
    def copy(self) -> EM3000DatagramContainer_QualityFactorDatagram_mapped: 
        """
        return a copy using the c++ default copy constructor
        """
    def count_datagrams_per_type(self) -> typing.Dict[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier, int]: ...
    def find_datagram_types(self) -> typing.List[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier]: ...
    def get_sorted_by_time(self) -> EM3000DatagramContainer_QualityFactorDatagram_mapped: ...
    def info_string(self, float_precision: int = 2) -> str: 
        """
        Return object information as string
        """
    def print(self, float_precision: int = 2) -> None: 
        """
        Print object information
        """
    def size(self) -> int: ...
    pass
class EM3000DatagramContainer_RawRangeAndAngle():
    @typing.overload
    def __call__(self, datagram_identifier: themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier) -> EM3000DatagramContainer_RawRangeAndAngle: ...
    @typing.overload
    def __call__(self, datagram_identifiers: typing.List[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier]) -> EM3000DatagramContainer_RawRangeAndAngle: ...
    def __copy__(self) -> EM3000DatagramContainer_RawRangeAndAngle: ...
    def __deepcopy__(self, arg0: dict) -> EM3000DatagramContainer_RawRangeAndAngle: ...
    @typing.overload
    def __getitem__(self, index: int) -> themachinethatgoesping.echosounders.em3000.datagrams.RawRangeAndAngle: ...
    @typing.overload
    def __getitem__(self, slice: themachinethatgoesping.tools.pyhelper.PyIndexerSlice) -> EM3000DatagramContainer_RawRangeAndAngle: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: 
        """
        Return object information as string
        """
    def __reversed__(self) -> EM3000DatagramContainer_RawRangeAndAngle: ...
    def __str__(self) -> str: 
        """
        Return object information as string
        """
    def break_by_time_diff(self, max_time_diff_seconds: float) -> typing.List[EM3000DatagramContainer_RawRangeAndAngle]: ...
    def copy(self) -> EM3000DatagramContainer_RawRangeAndAngle: 
        """
        return a copy using the c++ default copy constructor
        """
    def count_datagrams_per_type(self) -> typing.Dict[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier, int]: ...
    def find_datagram_types(self) -> typing.List[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier]: ...
    def get_sorted_by_time(self) -> EM3000DatagramContainer_RawRangeAndAngle: ...
    def info_string(self, float_precision: int = 2) -> str: 
        """
        Return object information as string
        """
    def print(self, float_precision: int = 2) -> None: 
        """
        Print object information
        """
    def size(self) -> int: ...
    pass
class EM3000DatagramContainer_RawRangeAndAngle_mapped():
    @typing.overload
    def __call__(self, datagram_identifier: themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier) -> EM3000DatagramContainer_RawRangeAndAngle_mapped: ...
    @typing.overload
    def __call__(self, datagram_identifiers: typing.List[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier]) -> EM3000DatagramContainer_RawRangeAndAngle_mapped: ...
    def __copy__(self) -> EM3000DatagramContainer_RawRangeAndAngle_mapped: ...
    def __deepcopy__(self, arg0: dict) -> EM3000DatagramContainer_RawRangeAndAngle_mapped: ...
    @typing.overload
    def __getitem__(self, index: int) -> themachinethatgoesping.echosounders.em3000.datagrams.RawRangeAndAngle: ...
    @typing.overload
    def __getitem__(self, slice: themachinethatgoesping.tools.pyhelper.PyIndexerSlice) -> EM3000DatagramContainer_RawRangeAndAngle_mapped: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: 
        """
        Return object information as string
        """
    def __reversed__(self) -> EM3000DatagramContainer_RawRangeAndAngle_mapped: ...
    def __str__(self) -> str: 
        """
        Return object information as string
        """
    def break_by_time_diff(self, max_time_diff_seconds: float) -> typing.List[EM3000DatagramContainer_RawRangeAndAngle_mapped]: ...
    def copy(self) -> EM3000DatagramContainer_RawRangeAndAngle_mapped: 
        """
        return a copy using the c++ default copy constructor
        """
    def count_datagrams_per_type(self) -> typing.Dict[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier, int]: ...
    def find_datagram_types(self) -> typing.List[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier]: ...
    def get_sorted_by_time(self) -> EM3000DatagramContainer_RawRangeAndAngle_mapped: ...
    def info_string(self, float_precision: int = 2) -> str: 
        """
        Return object information as string
        """
    def print(self, float_precision: int = 2) -> None: 
        """
        Print object information
        """
    def size(self) -> int: ...
    pass
class EM3000DatagramContainer_SeabedImageData():
    @typing.overload
    def __call__(self, datagram_identifier: themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier) -> EM3000DatagramContainer_SeabedImageData: ...
    @typing.overload
    def __call__(self, datagram_identifiers: typing.List[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier]) -> EM3000DatagramContainer_SeabedImageData: ...
    def __copy__(self) -> EM3000DatagramContainer_SeabedImageData: ...
    def __deepcopy__(self, arg0: dict) -> EM3000DatagramContainer_SeabedImageData: ...
    @typing.overload
    def __getitem__(self, index: int) -> themachinethatgoesping.echosounders.em3000.datagrams.SeabedImageData: ...
    @typing.overload
    def __getitem__(self, slice: themachinethatgoesping.tools.pyhelper.PyIndexerSlice) -> EM3000DatagramContainer_SeabedImageData: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: 
        """
        Return object information as string
        """
    def __reversed__(self) -> EM3000DatagramContainer_SeabedImageData: ...
    def __str__(self) -> str: 
        """
        Return object information as string
        """
    def break_by_time_diff(self, max_time_diff_seconds: float) -> typing.List[EM3000DatagramContainer_SeabedImageData]: ...
    def copy(self) -> EM3000DatagramContainer_SeabedImageData: 
        """
        return a copy using the c++ default copy constructor
        """
    def count_datagrams_per_type(self) -> typing.Dict[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier, int]: ...
    def find_datagram_types(self) -> typing.List[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier]: ...
    def get_sorted_by_time(self) -> EM3000DatagramContainer_SeabedImageData: ...
    def info_string(self, float_precision: int = 2) -> str: 
        """
        Return object information as string
        """
    def print(self, float_precision: int = 2) -> None: 
        """
        Print object information
        """
    def size(self) -> int: ...
    pass
class EM3000DatagramContainer_SeabedImageData_mapped():
    @typing.overload
    def __call__(self, datagram_identifier: themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier) -> EM3000DatagramContainer_SeabedImageData_mapped: ...
    @typing.overload
    def __call__(self, datagram_identifiers: typing.List[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier]) -> EM3000DatagramContainer_SeabedImageData_mapped: ...
    def __copy__(self) -> EM3000DatagramContainer_SeabedImageData_mapped: ...
    def __deepcopy__(self, arg0: dict) -> EM3000DatagramContainer_SeabedImageData_mapped: ...
    @typing.overload
    def __getitem__(self, index: int) -> themachinethatgoesping.echosounders.em3000.datagrams.SeabedImageData: ...
    @typing.overload
    def __getitem__(self, slice: themachinethatgoesping.tools.pyhelper.PyIndexerSlice) -> EM3000DatagramContainer_SeabedImageData_mapped: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: 
        """
        Return object information as string
        """
    def __reversed__(self) -> EM3000DatagramContainer_SeabedImageData_mapped: ...
    def __str__(self) -> str: 
        """
        Return object information as string
        """
    def break_by_time_diff(self, max_time_diff_seconds: float) -> typing.List[EM3000DatagramContainer_SeabedImageData_mapped]: ...
    def copy(self) -> EM3000DatagramContainer_SeabedImageData_mapped: 
        """
        return a copy using the c++ default copy constructor
        """
    def count_datagrams_per_type(self) -> typing.Dict[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier, int]: ...
    def find_datagram_types(self) -> typing.List[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier]: ...
    def get_sorted_by_time(self) -> EM3000DatagramContainer_SeabedImageData_mapped: ...
    def info_string(self, float_precision: int = 2) -> str: 
        """
        Return object information as string
        """
    def print(self, float_precision: int = 2) -> None: 
        """
        Print object information
        """
    def size(self) -> int: ...
    pass
class EM3000DatagramContainer_Unknown():
    @typing.overload
    def __call__(self, datagram_identifier: themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier) -> EM3000DatagramContainer_Unknown: ...
    @typing.overload
    def __call__(self, datagram_identifiers: typing.List[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier]) -> EM3000DatagramContainer_Unknown: ...
    def __copy__(self) -> EM3000DatagramContainer_Unknown: ...
    def __deepcopy__(self, arg0: dict) -> EM3000DatagramContainer_Unknown: ...
    @typing.overload
    def __getitem__(self, index: int) -> themachinethatgoesping.echosounders.em3000.datagrams.EM3000Unknown: ...
    @typing.overload
    def __getitem__(self, slice: themachinethatgoesping.tools.pyhelper.PyIndexerSlice) -> EM3000DatagramContainer_Unknown: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: 
        """
        Return object information as string
        """
    def __reversed__(self) -> EM3000DatagramContainer_Unknown: ...
    def __str__(self) -> str: 
        """
        Return object information as string
        """
    def break_by_time_diff(self, max_time_diff_seconds: float) -> typing.List[EM3000DatagramContainer_Unknown]: ...
    def copy(self) -> EM3000DatagramContainer_Unknown: 
        """
        return a copy using the c++ default copy constructor
        """
    def count_datagrams_per_type(self) -> typing.Dict[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier, int]: ...
    def find_datagram_types(self) -> typing.List[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier]: ...
    def get_sorted_by_time(self) -> EM3000DatagramContainer_Unknown: ...
    def info_string(self, float_precision: int = 2) -> str: 
        """
        Return object information as string
        """
    def print(self, float_precision: int = 2) -> None: 
        """
        Print object information
        """
    def size(self) -> int: ...
    pass
class EM3000DatagramContainer_Unknown_mapped():
    @typing.overload
    def __call__(self, datagram_identifier: themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier) -> EM3000DatagramContainer_Unknown_mapped: ...
    @typing.overload
    def __call__(self, datagram_identifiers: typing.List[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier]) -> EM3000DatagramContainer_Unknown_mapped: ...
    def __copy__(self) -> EM3000DatagramContainer_Unknown_mapped: ...
    def __deepcopy__(self, arg0: dict) -> EM3000DatagramContainer_Unknown_mapped: ...
    @typing.overload
    def __getitem__(self, index: int) -> themachinethatgoesping.echosounders.em3000.datagrams.EM3000Unknown: ...
    @typing.overload
    def __getitem__(self, slice: themachinethatgoesping.tools.pyhelper.PyIndexerSlice) -> EM3000DatagramContainer_Unknown_mapped: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: 
        """
        Return object information as string
        """
    def __reversed__(self) -> EM3000DatagramContainer_Unknown_mapped: ...
    def __str__(self) -> str: 
        """
        Return object information as string
        """
    def break_by_time_diff(self, max_time_diff_seconds: float) -> typing.List[EM3000DatagramContainer_Unknown_mapped]: ...
    def copy(self) -> EM3000DatagramContainer_Unknown_mapped: 
        """
        return a copy using the c++ default copy constructor
        """
    def count_datagrams_per_type(self) -> typing.Dict[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier, int]: ...
    def find_datagram_types(self) -> typing.List[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier]: ...
    def get_sorted_by_time(self) -> EM3000DatagramContainer_Unknown_mapped: ...
    def info_string(self, float_precision: int = 2) -> str: 
        """
        Return object information as string
        """
    def print(self, float_precision: int = 2) -> None: 
        """
        Print object information
        """
    def size(self) -> int: ...
    pass
class EM3000DatagramContainer_Variant():
    @typing.overload
    def __call__(self, datagram_identifier: themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier) -> EM3000DatagramContainer_Variant: ...
    @typing.overload
    def __call__(self, datagram_identifiers: typing.List[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier]) -> EM3000DatagramContainer_Variant: ...
    def __copy__(self) -> EM3000DatagramContainer_Variant: ...
    def __deepcopy__(self, arg0: dict) -> EM3000DatagramContainer_Variant: ...
    @typing.overload
    def __getitem__(self, index: int) -> typing.Union[themachinethatgoesping.echosounders.em3000.datagrams.EM3000Datagram, themachinethatgoesping.echosounders.em3000.datagrams.XYZDatagram, themachinethatgoesping.echosounders.em3000.datagrams.ExtraDetections, themachinethatgoesping.echosounders.em3000.datagrams.RawRangeAndAngle, themachinethatgoesping.echosounders.em3000.datagrams.SeabedImageData, themachinethatgoesping.echosounders.em3000.datagrams.WaterColumnDatagram, themachinethatgoesping.echosounders.em3000.datagrams.QualityFactorDatagram, themachinethatgoesping.echosounders.em3000.datagrams.EM3000Unknown]: ...
    @typing.overload
    def __getitem__(self, slice: themachinethatgoesping.tools.pyhelper.PyIndexerSlice) -> EM3000DatagramContainer_Variant: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: 
        """
        Return object information as string
        """
    def __reversed__(self) -> EM3000DatagramContainer_Variant: ...
    def __str__(self) -> str: 
        """
        Return object information as string
        """
    def break_by_time_diff(self, max_time_diff_seconds: float) -> typing.List[EM3000DatagramContainer_Variant]: ...
    def copy(self) -> EM3000DatagramContainer_Variant: 
        """
        return a copy using the c++ default copy constructor
        """
    def count_datagrams_per_type(self) -> typing.Dict[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier, int]: ...
    def find_datagram_types(self) -> typing.List[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier]: ...
    def get_sorted_by_time(self) -> EM3000DatagramContainer_Variant: ...
    def info_string(self, float_precision: int = 2) -> str: 
        """
        Return object information as string
        """
    def print(self, float_precision: int = 2) -> None: 
        """
        Print object information
        """
    def size(self) -> int: ...
    pass
class EM3000DatagramContainer_Variant_mapped():
    @typing.overload
    def __call__(self, datagram_identifier: themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier) -> EM3000DatagramContainer_Variant_mapped: ...
    @typing.overload
    def __call__(self, datagram_identifiers: typing.List[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier]) -> EM3000DatagramContainer_Variant_mapped: ...
    def __copy__(self) -> EM3000DatagramContainer_Variant_mapped: ...
    def __deepcopy__(self, arg0: dict) -> EM3000DatagramContainer_Variant_mapped: ...
    @typing.overload
    def __getitem__(self, index: int) -> typing.Union[themachinethatgoesping.echosounders.em3000.datagrams.EM3000Datagram, themachinethatgoesping.echosounders.em3000.datagrams.XYZDatagram, themachinethatgoesping.echosounders.em3000.datagrams.ExtraDetections, themachinethatgoesping.echosounders.em3000.datagrams.RawRangeAndAngle, themachinethatgoesping.echosounders.em3000.datagrams.SeabedImageData, themachinethatgoesping.echosounders.em3000.datagrams.WaterColumnDatagram, themachinethatgoesping.echosounders.em3000.datagrams.QualityFactorDatagram, themachinethatgoesping.echosounders.em3000.datagrams.EM3000Unknown]: ...
    @typing.overload
    def __getitem__(self, slice: themachinethatgoesping.tools.pyhelper.PyIndexerSlice) -> EM3000DatagramContainer_Variant_mapped: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: 
        """
        Return object information as string
        """
    def __reversed__(self) -> EM3000DatagramContainer_Variant_mapped: ...
    def __str__(self) -> str: 
        """
        Return object information as string
        """
    def break_by_time_diff(self, max_time_diff_seconds: float) -> typing.List[EM3000DatagramContainer_Variant_mapped]: ...
    def copy(self) -> EM3000DatagramContainer_Variant_mapped: 
        """
        return a copy using the c++ default copy constructor
        """
    def count_datagrams_per_type(self) -> typing.Dict[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier, int]: ...
    def find_datagram_types(self) -> typing.List[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier]: ...
    def get_sorted_by_time(self) -> EM3000DatagramContainer_Variant_mapped: ...
    def info_string(self, float_precision: int = 2) -> str: 
        """
        Return object information as string
        """
    def print(self, float_precision: int = 2) -> None: 
        """
        Print object information
        """
    def size(self) -> int: ...
    pass
class EM3000DatagramContainer_WaterColumnDatagram():
    @typing.overload
    def __call__(self, datagram_identifier: themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier) -> EM3000DatagramContainer_WaterColumnDatagram: ...
    @typing.overload
    def __call__(self, datagram_identifiers: typing.List[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier]) -> EM3000DatagramContainer_WaterColumnDatagram: ...
    def __copy__(self) -> EM3000DatagramContainer_WaterColumnDatagram: ...
    def __deepcopy__(self, arg0: dict) -> EM3000DatagramContainer_WaterColumnDatagram: ...
    @typing.overload
    def __getitem__(self, index: int) -> themachinethatgoesping.echosounders.em3000.datagrams.WaterColumnDatagram: ...
    @typing.overload
    def __getitem__(self, slice: themachinethatgoesping.tools.pyhelper.PyIndexerSlice) -> EM3000DatagramContainer_WaterColumnDatagram: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: 
        """
        Return object information as string
        """
    def __reversed__(self) -> EM3000DatagramContainer_WaterColumnDatagram: ...
    def __str__(self) -> str: 
        """
        Return object information as string
        """
    def break_by_time_diff(self, max_time_diff_seconds: float) -> typing.List[EM3000DatagramContainer_WaterColumnDatagram]: ...
    def copy(self) -> EM3000DatagramContainer_WaterColumnDatagram: 
        """
        return a copy using the c++ default copy constructor
        """
    def count_datagrams_per_type(self) -> typing.Dict[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier, int]: ...
    def find_datagram_types(self) -> typing.List[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier]: ...
    def get_sorted_by_time(self) -> EM3000DatagramContainer_WaterColumnDatagram: ...
    def info_string(self, float_precision: int = 2) -> str: 
        """
        Return object information as string
        """
    def print(self, float_precision: int = 2) -> None: 
        """
        Print object information
        """
    def size(self) -> int: ...
    pass
class EM3000DatagramContainer_WaterColumnDatagram_mapped():
    @typing.overload
    def __call__(self, datagram_identifier: themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier) -> EM3000DatagramContainer_WaterColumnDatagram_mapped: ...
    @typing.overload
    def __call__(self, datagram_identifiers: typing.List[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier]) -> EM3000DatagramContainer_WaterColumnDatagram_mapped: ...
    def __copy__(self) -> EM3000DatagramContainer_WaterColumnDatagram_mapped: ...
    def __deepcopy__(self, arg0: dict) -> EM3000DatagramContainer_WaterColumnDatagram_mapped: ...
    @typing.overload
    def __getitem__(self, index: int) -> themachinethatgoesping.echosounders.em3000.datagrams.WaterColumnDatagram: ...
    @typing.overload
    def __getitem__(self, slice: themachinethatgoesping.tools.pyhelper.PyIndexerSlice) -> EM3000DatagramContainer_WaterColumnDatagram_mapped: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: 
        """
        Return object information as string
        """
    def __reversed__(self) -> EM3000DatagramContainer_WaterColumnDatagram_mapped: ...
    def __str__(self) -> str: 
        """
        Return object information as string
        """
    def break_by_time_diff(self, max_time_diff_seconds: float) -> typing.List[EM3000DatagramContainer_WaterColumnDatagram_mapped]: ...
    def copy(self) -> EM3000DatagramContainer_WaterColumnDatagram_mapped: 
        """
        return a copy using the c++ default copy constructor
        """
    def count_datagrams_per_type(self) -> typing.Dict[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier, int]: ...
    def find_datagram_types(self) -> typing.List[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier]: ...
    def get_sorted_by_time(self) -> EM3000DatagramContainer_WaterColumnDatagram_mapped: ...
    def info_string(self, float_precision: int = 2) -> str: 
        """
        Return object information as string
        """
    def print(self, float_precision: int = 2) -> None: 
        """
        Print object information
        """
    def size(self) -> int: ...
    pass
class EM3000DatagramContainer_XYZDatagram():
    @typing.overload
    def __call__(self, datagram_identifier: themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier) -> EM3000DatagramContainer_XYZDatagram: ...
    @typing.overload
    def __call__(self, datagram_identifiers: typing.List[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier]) -> EM3000DatagramContainer_XYZDatagram: ...
    def __copy__(self) -> EM3000DatagramContainer_XYZDatagram: ...
    def __deepcopy__(self, arg0: dict) -> EM3000DatagramContainer_XYZDatagram: ...
    @typing.overload
    def __getitem__(self, index: int) -> themachinethatgoesping.echosounders.em3000.datagrams.XYZDatagram: ...
    @typing.overload
    def __getitem__(self, slice: themachinethatgoesping.tools.pyhelper.PyIndexerSlice) -> EM3000DatagramContainer_XYZDatagram: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: 
        """
        Return object information as string
        """
    def __reversed__(self) -> EM3000DatagramContainer_XYZDatagram: ...
    def __str__(self) -> str: 
        """
        Return object information as string
        """
    def break_by_time_diff(self, max_time_diff_seconds: float) -> typing.List[EM3000DatagramContainer_XYZDatagram]: ...
    def copy(self) -> EM3000DatagramContainer_XYZDatagram: 
        """
        return a copy using the c++ default copy constructor
        """
    def count_datagrams_per_type(self) -> typing.Dict[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier, int]: ...
    def find_datagram_types(self) -> typing.List[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier]: ...
    def get_sorted_by_time(self) -> EM3000DatagramContainer_XYZDatagram: ...
    def info_string(self, float_precision: int = 2) -> str: 
        """
        Return object information as string
        """
    def print(self, float_precision: int = 2) -> None: 
        """
        Print object information
        """
    def size(self) -> int: ...
    pass
class EM3000DatagramContainer_XYZDatagram_mapped():
    @typing.overload
    def __call__(self, datagram_identifier: themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier) -> EM3000DatagramContainer_XYZDatagram_mapped: ...
    @typing.overload
    def __call__(self, datagram_identifiers: typing.List[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier]) -> EM3000DatagramContainer_XYZDatagram_mapped: ...
    def __copy__(self) -> EM3000DatagramContainer_XYZDatagram_mapped: ...
    def __deepcopy__(self, arg0: dict) -> EM3000DatagramContainer_XYZDatagram_mapped: ...
    @typing.overload
    def __getitem__(self, index: int) -> themachinethatgoesping.echosounders.em3000.datagrams.XYZDatagram: ...
    @typing.overload
    def __getitem__(self, slice: themachinethatgoesping.tools.pyhelper.PyIndexerSlice) -> EM3000DatagramContainer_XYZDatagram_mapped: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: 
        """
        Return object information as string
        """
    def __reversed__(self) -> EM3000DatagramContainer_XYZDatagram_mapped: ...
    def __str__(self) -> str: 
        """
        Return object information as string
        """
    def break_by_time_diff(self, max_time_diff_seconds: float) -> typing.List[EM3000DatagramContainer_XYZDatagram_mapped]: ...
    def copy(self) -> EM3000DatagramContainer_XYZDatagram_mapped: 
        """
        return a copy using the c++ default copy constructor
        """
    def count_datagrams_per_type(self) -> typing.Dict[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier, int]: ...
    def find_datagram_types(self) -> typing.List[themachinethatgoesping.echosounders.em3000.t_EM3000DatagramIdentifier]: ...
    def get_sorted_by_time(self) -> EM3000DatagramContainer_XYZDatagram_mapped: ...
    def info_string(self, float_precision: int = 2) -> str: 
        """
        Return object information as string
        """
    def print(self, float_precision: int = 2) -> None: 
        """
        Print object information
        """
    def size(self) -> int: ...
    pass
