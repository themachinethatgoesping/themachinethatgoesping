"""
M that holds functions used for image processing functions
"""
from __future__ import annotations
import numpy
import typing
__all__: list[str] = ['UniformAxis', 'backward_map_bilinear', 'backward_map_bilinear_add', 'backward_map_nearest', 'backward_map_nearest_add', 'find_local_maxima', 'find_local_maxima2', 'grow_regions']
class UniformAxis:
    """
    """
    @typing.overload
    def __init__(self, origin: typing.SupportsFloat, spacing: typing.SupportsFloat, size: typing.SupportsInt) -> None:
        ...
    @typing.overload
    def __init__(self, coordinates: numpy.ndarray[numpy.float64], tolerance: typing.SupportsFloat = 1e-09) -> None:
        ...
    @typing.overload
    def __init__(self, coordinates: numpy.ndarray[numpy.float32], tolerance: typing.SupportsFloat = 1e-09) -> None:
        ...
    @property
    def origin(self) -> float:
        ...
    @origin.setter
    def origin(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def size(self) -> int:
        ...
    @size.setter
    def size(self, arg0: typing.SupportsInt) -> None:
        ...
    @property
    def spacing(self) -> float:
        ...
    @spacing.setter
    def spacing(self, arg0: typing.SupportsFloat) -> None:
        ...
@typing.overload
def backward_map_bilinear(reference: numpy.ndarray[numpy.float64], reference_x: numpy.ndarray[numpy.float32], reference_y: numpy.ndarray[numpy.float32], new_x: numpy.ndarray[numpy.float32], new_y: numpy.ndarray[numpy.float32], mp_cores: typing.SupportsInt = 1) -> numpy.ndarray[numpy.float64]:
    ...
@typing.overload
def backward_map_bilinear(reference: numpy.ndarray[numpy.float64], reference_x: numpy.ndarray[numpy.float64], reference_y: numpy.ndarray[numpy.float64], new_x: numpy.ndarray[numpy.float64], new_y: numpy.ndarray[numpy.float64], mp_cores: typing.SupportsInt = 1) -> numpy.ndarray[numpy.float64]:
    ...
@typing.overload
def backward_map_bilinear(reference: numpy.ndarray[numpy.float32], reference_x: numpy.ndarray[numpy.float32], reference_y: numpy.ndarray[numpy.float32], new_x: numpy.ndarray[numpy.float32], new_y: numpy.ndarray[numpy.float32], mp_cores: typing.SupportsInt = 1) -> numpy.ndarray[numpy.float32]:
    ...
@typing.overload
def backward_map_bilinear(reference: numpy.ndarray[numpy.float32], reference_x: numpy.ndarray[numpy.float64], reference_y: numpy.ndarray[numpy.float64], new_x: numpy.ndarray[numpy.float64], new_y: numpy.ndarray[numpy.float64], mp_cores: typing.SupportsInt = 1) -> numpy.ndarray[numpy.float32]:
    ...
@typing.overload
def backward_map_bilinear(reference: numpy.ndarray[numpy.int64], reference_x: numpy.ndarray[numpy.float32], reference_y: numpy.ndarray[numpy.float32], new_x: numpy.ndarray[numpy.float32], new_y: numpy.ndarray[numpy.float32], mp_cores: typing.SupportsInt = 1) -> numpy.ndarray[numpy.int64]:
    ...
@typing.overload
def backward_map_bilinear(reference: numpy.ndarray[numpy.int64], reference_x: numpy.ndarray[numpy.float64], reference_y: numpy.ndarray[numpy.float64], new_x: numpy.ndarray[numpy.float64], new_y: numpy.ndarray[numpy.float64], mp_cores: typing.SupportsInt = 1) -> numpy.ndarray[numpy.int64]:
    ...
@typing.overload
def backward_map_bilinear(reference: numpy.ndarray[numpy.int32], reference_x: numpy.ndarray[numpy.float32], reference_y: numpy.ndarray[numpy.float32], new_x: numpy.ndarray[numpy.float32], new_y: numpy.ndarray[numpy.float32], mp_cores: typing.SupportsInt = 1) -> numpy.ndarray[numpy.int32]:
    ...
@typing.overload
def backward_map_bilinear(reference: numpy.ndarray[numpy.int32], reference_x: numpy.ndarray[numpy.float64], reference_y: numpy.ndarray[numpy.float64], new_x: numpy.ndarray[numpy.float64], new_y: numpy.ndarray[numpy.float64], mp_cores: typing.SupportsInt = 1) -> numpy.ndarray[numpy.int32]:
    ...
@typing.overload
def backward_map_bilinear(reference: numpy.ndarray[numpy.int16], reference_x: numpy.ndarray[numpy.float32], reference_y: numpy.ndarray[numpy.float32], new_x: numpy.ndarray[numpy.float32], new_y: numpy.ndarray[numpy.float32], mp_cores: typing.SupportsInt = 1) -> numpy.ndarray[numpy.int16]:
    ...
@typing.overload
def backward_map_bilinear(reference: numpy.ndarray[numpy.int16], reference_x: numpy.ndarray[numpy.float64], reference_y: numpy.ndarray[numpy.float64], new_x: numpy.ndarray[numpy.float64], new_y: numpy.ndarray[numpy.float64], mp_cores: typing.SupportsInt = 1) -> numpy.ndarray[numpy.int16]:
    ...
@typing.overload
def backward_map_bilinear(reference: numpy.ndarray[numpy.int8], reference_x: numpy.ndarray[numpy.float32], reference_y: numpy.ndarray[numpy.float32], new_x: numpy.ndarray[numpy.float32], new_y: numpy.ndarray[numpy.float32], mp_cores: typing.SupportsInt = 1) -> numpy.ndarray[numpy.int8]:
    ...
@typing.overload
def backward_map_bilinear(reference: numpy.ndarray[numpy.int8], reference_x: numpy.ndarray[numpy.float64], reference_y: numpy.ndarray[numpy.float64], new_x: numpy.ndarray[numpy.float64], new_y: numpy.ndarray[numpy.float64], mp_cores: typing.SupportsInt = 1) -> numpy.ndarray[numpy.int8]:
    ...
@typing.overload
def backward_map_bilinear_add(reference: numpy.ndarray[numpy.float64], reference_x: numpy.ndarray[numpy.float32], reference_y: numpy.ndarray[numpy.float32], second_image: numpy.ndarray[numpy.float64], second_x: numpy.ndarray[numpy.float32], second_y: numpy.ndarray[numpy.float32], mp_cores: typing.SupportsInt = 1) -> None:
    ...
@typing.overload
def backward_map_bilinear_add(reference: numpy.ndarray[numpy.float64], reference_x: numpy.ndarray[numpy.float64], reference_y: numpy.ndarray[numpy.float64], second_image: numpy.ndarray[numpy.float64], second_x: numpy.ndarray[numpy.float64], second_y: numpy.ndarray[numpy.float64], mp_cores: typing.SupportsInt = 1) -> None:
    ...
@typing.overload
def backward_map_bilinear_add(reference: numpy.ndarray[numpy.float32], reference_x: numpy.ndarray[numpy.float32], reference_y: numpy.ndarray[numpy.float32], second_image: numpy.ndarray[numpy.float32], second_x: numpy.ndarray[numpy.float32], second_y: numpy.ndarray[numpy.float32], mp_cores: typing.SupportsInt = 1) -> None:
    ...
@typing.overload
def backward_map_bilinear_add(reference: numpy.ndarray[numpy.float32], reference_x: numpy.ndarray[numpy.float64], reference_y: numpy.ndarray[numpy.float64], second_image: numpy.ndarray[numpy.float32], second_x: numpy.ndarray[numpy.float64], second_y: numpy.ndarray[numpy.float64], mp_cores: typing.SupportsInt = 1) -> None:
    ...
@typing.overload
def backward_map_bilinear_add(reference: numpy.ndarray[numpy.int64], reference_x: numpy.ndarray[numpy.float32], reference_y: numpy.ndarray[numpy.float32], second_image: numpy.ndarray[numpy.int64], second_x: numpy.ndarray[numpy.float32], second_y: numpy.ndarray[numpy.float32], mp_cores: typing.SupportsInt = 1) -> None:
    ...
@typing.overload
def backward_map_bilinear_add(reference: numpy.ndarray[numpy.int64], reference_x: numpy.ndarray[numpy.float64], reference_y: numpy.ndarray[numpy.float64], second_image: numpy.ndarray[numpy.int64], second_x: numpy.ndarray[numpy.float64], second_y: numpy.ndarray[numpy.float64], mp_cores: typing.SupportsInt = 1) -> None:
    ...
@typing.overload
def backward_map_bilinear_add(reference: numpy.ndarray[numpy.int32], reference_x: numpy.ndarray[numpy.float32], reference_y: numpy.ndarray[numpy.float32], second_image: numpy.ndarray[numpy.int32], second_x: numpy.ndarray[numpy.float32], second_y: numpy.ndarray[numpy.float32], mp_cores: typing.SupportsInt = 1) -> None:
    ...
@typing.overload
def backward_map_bilinear_add(reference: numpy.ndarray[numpy.int32], reference_x: numpy.ndarray[numpy.float64], reference_y: numpy.ndarray[numpy.float64], second_image: numpy.ndarray[numpy.int32], second_x: numpy.ndarray[numpy.float64], second_y: numpy.ndarray[numpy.float64], mp_cores: typing.SupportsInt = 1) -> None:
    ...
@typing.overload
def backward_map_bilinear_add(reference: numpy.ndarray[numpy.int16], reference_x: numpy.ndarray[numpy.float32], reference_y: numpy.ndarray[numpy.float32], second_image: numpy.ndarray[numpy.int16], second_x: numpy.ndarray[numpy.float32], second_y: numpy.ndarray[numpy.float32], mp_cores: typing.SupportsInt = 1) -> None:
    ...
@typing.overload
def backward_map_bilinear_add(reference: numpy.ndarray[numpy.int16], reference_x: numpy.ndarray[numpy.float64], reference_y: numpy.ndarray[numpy.float64], second_image: numpy.ndarray[numpy.int16], second_x: numpy.ndarray[numpy.float64], second_y: numpy.ndarray[numpy.float64], mp_cores: typing.SupportsInt = 1) -> None:
    ...
@typing.overload
def backward_map_bilinear_add(reference: numpy.ndarray[numpy.int8], reference_x: numpy.ndarray[numpy.float32], reference_y: numpy.ndarray[numpy.float32], second_image: numpy.ndarray[numpy.int8], second_x: numpy.ndarray[numpy.float32], second_y: numpy.ndarray[numpy.float32], mp_cores: typing.SupportsInt = 1) -> None:
    ...
@typing.overload
def backward_map_bilinear_add(reference: numpy.ndarray[numpy.int8], reference_x: numpy.ndarray[numpy.float64], reference_y: numpy.ndarray[numpy.float64], second_image: numpy.ndarray[numpy.int8], second_x: numpy.ndarray[numpy.float64], second_y: numpy.ndarray[numpy.float64], mp_cores: typing.SupportsInt = 1) -> None:
    ...
@typing.overload
def backward_map_nearest(reference: numpy.ndarray[numpy.float64], reference_x: numpy.ndarray[numpy.float32], reference_y: numpy.ndarray[numpy.float32], new_x: numpy.ndarray[numpy.float32], new_y: numpy.ndarray[numpy.float32], mp_cores: typing.SupportsInt = 1) -> numpy.ndarray[numpy.float64]:
    ...
@typing.overload
def backward_map_nearest(reference: numpy.ndarray[numpy.float64], reference_x: numpy.ndarray[numpy.float64], reference_y: numpy.ndarray[numpy.float64], new_x: numpy.ndarray[numpy.float64], new_y: numpy.ndarray[numpy.float64], mp_cores: typing.SupportsInt = 1) -> numpy.ndarray[numpy.float64]:
    ...
@typing.overload
def backward_map_nearest(reference: numpy.ndarray[numpy.float32], reference_x: numpy.ndarray[numpy.float32], reference_y: numpy.ndarray[numpy.float32], new_x: numpy.ndarray[numpy.float32], new_y: numpy.ndarray[numpy.float32], mp_cores: typing.SupportsInt = 1) -> numpy.ndarray[numpy.float32]:
    ...
@typing.overload
def backward_map_nearest(reference: numpy.ndarray[numpy.float32], reference_x: numpy.ndarray[numpy.float64], reference_y: numpy.ndarray[numpy.float64], new_x: numpy.ndarray[numpy.float64], new_y: numpy.ndarray[numpy.float64], mp_cores: typing.SupportsInt = 1) -> numpy.ndarray[numpy.float32]:
    ...
@typing.overload
def backward_map_nearest(reference: numpy.ndarray[numpy.int64], reference_x: numpy.ndarray[numpy.float32], reference_y: numpy.ndarray[numpy.float32], new_x: numpy.ndarray[numpy.float32], new_y: numpy.ndarray[numpy.float32], mp_cores: typing.SupportsInt = 1) -> numpy.ndarray[numpy.int64]:
    ...
@typing.overload
def backward_map_nearest(reference: numpy.ndarray[numpy.int64], reference_x: numpy.ndarray[numpy.float64], reference_y: numpy.ndarray[numpy.float64], new_x: numpy.ndarray[numpy.float64], new_y: numpy.ndarray[numpy.float64], mp_cores: typing.SupportsInt = 1) -> numpy.ndarray[numpy.int64]:
    ...
@typing.overload
def backward_map_nearest(reference: numpy.ndarray[numpy.int32], reference_x: numpy.ndarray[numpy.float32], reference_y: numpy.ndarray[numpy.float32], new_x: numpy.ndarray[numpy.float32], new_y: numpy.ndarray[numpy.float32], mp_cores: typing.SupportsInt = 1) -> numpy.ndarray[numpy.int32]:
    ...
@typing.overload
def backward_map_nearest(reference: numpy.ndarray[numpy.int32], reference_x: numpy.ndarray[numpy.float64], reference_y: numpy.ndarray[numpy.float64], new_x: numpy.ndarray[numpy.float64], new_y: numpy.ndarray[numpy.float64], mp_cores: typing.SupportsInt = 1) -> numpy.ndarray[numpy.int32]:
    ...
@typing.overload
def backward_map_nearest(reference: numpy.ndarray[numpy.int16], reference_x: numpy.ndarray[numpy.float32], reference_y: numpy.ndarray[numpy.float32], new_x: numpy.ndarray[numpy.float32], new_y: numpy.ndarray[numpy.float32], mp_cores: typing.SupportsInt = 1) -> numpy.ndarray[numpy.int16]:
    ...
@typing.overload
def backward_map_nearest(reference: numpy.ndarray[numpy.int16], reference_x: numpy.ndarray[numpy.float64], reference_y: numpy.ndarray[numpy.float64], new_x: numpy.ndarray[numpy.float64], new_y: numpy.ndarray[numpy.float64], mp_cores: typing.SupportsInt = 1) -> numpy.ndarray[numpy.int16]:
    ...
@typing.overload
def backward_map_nearest(reference: numpy.ndarray[numpy.int8], reference_x: numpy.ndarray[numpy.float32], reference_y: numpy.ndarray[numpy.float32], new_x: numpy.ndarray[numpy.float32], new_y: numpy.ndarray[numpy.float32], mp_cores: typing.SupportsInt = 1) -> numpy.ndarray[numpy.int8]:
    ...
@typing.overload
def backward_map_nearest(reference: numpy.ndarray[numpy.int8], reference_x: numpy.ndarray[numpy.float64], reference_y: numpy.ndarray[numpy.float64], new_x: numpy.ndarray[numpy.float64], new_y: numpy.ndarray[numpy.float64], mp_cores: typing.SupportsInt = 1) -> numpy.ndarray[numpy.int8]:
    ...
@typing.overload
def backward_map_nearest_add(reference: numpy.ndarray[numpy.float64], reference_x: numpy.ndarray[numpy.float32], reference_y: numpy.ndarray[numpy.float32], second_image: numpy.ndarray[numpy.float64], second_x: numpy.ndarray[numpy.float32], second_y: numpy.ndarray[numpy.float32], mp_cores: typing.SupportsInt = 1) -> None:
    ...
@typing.overload
def backward_map_nearest_add(reference: numpy.ndarray[numpy.float64], reference_x: numpy.ndarray[numpy.float64], reference_y: numpy.ndarray[numpy.float64], second_image: numpy.ndarray[numpy.float64], second_x: numpy.ndarray[numpy.float64], second_y: numpy.ndarray[numpy.float64], mp_cores: typing.SupportsInt = 1) -> None:
    ...
@typing.overload
def backward_map_nearest_add(reference: numpy.ndarray[numpy.float32], reference_x: numpy.ndarray[numpy.float32], reference_y: numpy.ndarray[numpy.float32], second_image: numpy.ndarray[numpy.float32], second_x: numpy.ndarray[numpy.float32], second_y: numpy.ndarray[numpy.float32], mp_cores: typing.SupportsInt = 1) -> None:
    ...
@typing.overload
def backward_map_nearest_add(reference: numpy.ndarray[numpy.float32], reference_x: numpy.ndarray[numpy.float64], reference_y: numpy.ndarray[numpy.float64], second_image: numpy.ndarray[numpy.float32], second_x: numpy.ndarray[numpy.float64], second_y: numpy.ndarray[numpy.float64], mp_cores: typing.SupportsInt = 1) -> None:
    ...
@typing.overload
def backward_map_nearest_add(reference: numpy.ndarray[numpy.int64], reference_x: numpy.ndarray[numpy.float32], reference_y: numpy.ndarray[numpy.float32], second_image: numpy.ndarray[numpy.int64], second_x: numpy.ndarray[numpy.float32], second_y: numpy.ndarray[numpy.float32], mp_cores: typing.SupportsInt = 1) -> None:
    ...
@typing.overload
def backward_map_nearest_add(reference: numpy.ndarray[numpy.int64], reference_x: numpy.ndarray[numpy.float64], reference_y: numpy.ndarray[numpy.float64], second_image: numpy.ndarray[numpy.int64], second_x: numpy.ndarray[numpy.float64], second_y: numpy.ndarray[numpy.float64], mp_cores: typing.SupportsInt = 1) -> None:
    ...
@typing.overload
def backward_map_nearest_add(reference: numpy.ndarray[numpy.int32], reference_x: numpy.ndarray[numpy.float32], reference_y: numpy.ndarray[numpy.float32], second_image: numpy.ndarray[numpy.int32], second_x: numpy.ndarray[numpy.float32], second_y: numpy.ndarray[numpy.float32], mp_cores: typing.SupportsInt = 1) -> None:
    ...
@typing.overload
def backward_map_nearest_add(reference: numpy.ndarray[numpy.int32], reference_x: numpy.ndarray[numpy.float64], reference_y: numpy.ndarray[numpy.float64], second_image: numpy.ndarray[numpy.int32], second_x: numpy.ndarray[numpy.float64], second_y: numpy.ndarray[numpy.float64], mp_cores: typing.SupportsInt = 1) -> None:
    ...
@typing.overload
def backward_map_nearest_add(reference: numpy.ndarray[numpy.int16], reference_x: numpy.ndarray[numpy.float32], reference_y: numpy.ndarray[numpy.float32], second_image: numpy.ndarray[numpy.int16], second_x: numpy.ndarray[numpy.float32], second_y: numpy.ndarray[numpy.float32], mp_cores: typing.SupportsInt = 1) -> None:
    ...
@typing.overload
def backward_map_nearest_add(reference: numpy.ndarray[numpy.int16], reference_x: numpy.ndarray[numpy.float64], reference_y: numpy.ndarray[numpy.float64], second_image: numpy.ndarray[numpy.int16], second_x: numpy.ndarray[numpy.float64], second_y: numpy.ndarray[numpy.float64], mp_cores: typing.SupportsInt = 1) -> None:
    ...
@typing.overload
def backward_map_nearest_add(reference: numpy.ndarray[numpy.int8], reference_x: numpy.ndarray[numpy.float32], reference_y: numpy.ndarray[numpy.float32], second_image: numpy.ndarray[numpy.int8], second_x: numpy.ndarray[numpy.float32], second_y: numpy.ndarray[numpy.float32], mp_cores: typing.SupportsInt = 1) -> None:
    ...
@typing.overload
def backward_map_nearest_add(reference: numpy.ndarray[numpy.int8], reference_x: numpy.ndarray[numpy.float64], reference_y: numpy.ndarray[numpy.float64], second_image: numpy.ndarray[numpy.int8], second_x: numpy.ndarray[numpy.float64], second_y: numpy.ndarray[numpy.float64], mp_cores: typing.SupportsInt = 1) -> None:
    ...
@typing.overload
def find_local_maxima(data: numpy.ndarray[numpy.float64], threshold: typing.SupportsFloat | None = None, accept_nans: bool = True, mp_cores: typing.SupportsInt = 1) -> tuple[list[int], list[int], list[int], list[float]]:
    ...
@typing.overload
def find_local_maxima(data: numpy.ndarray[numpy.float64], threshold: typing.SupportsFloat | None = None, accept_nans: bool = True, mp_cores: typing.SupportsInt = 1) -> tuple[list[int], list[int], list[float]]:
    ...
@typing.overload
def find_local_maxima(data: numpy.ndarray[numpy.float64], threshold: typing.SupportsFloat | None = None, accept_nans: bool = True, mp_cores: typing.SupportsInt = 1) -> tuple[list[int], list[float]]:
    ...
@typing.overload
def find_local_maxima(data: numpy.ndarray[numpy.float32], threshold: typing.SupportsFloat | None = None, accept_nans: bool = True, mp_cores: typing.SupportsInt = 1) -> tuple[list[int], list[int], list[int], list[float]]:
    ...
@typing.overload
def find_local_maxima(data: numpy.ndarray[numpy.float32], threshold: typing.SupportsFloat | None = None, accept_nans: bool = True, mp_cores: typing.SupportsInt = 1) -> tuple[list[int], list[int], list[float]]:
    ...
@typing.overload
def find_local_maxima(data: numpy.ndarray[numpy.float32], threshold: typing.SupportsFloat | None = None, accept_nans: bool = True, mp_cores: typing.SupportsInt = 1) -> tuple[list[int], list[float]]:
    ...
@typing.overload
def find_local_maxima(data: numpy.ndarray[numpy.int64], threshold: typing.SupportsInt | None = None, accept_nans: bool = True, mp_cores: typing.SupportsInt = 1) -> tuple[list[int], list[int], list[int], list[int]]:
    ...
@typing.overload
def find_local_maxima(data: numpy.ndarray[numpy.int64], threshold: typing.SupportsInt | None = None, accept_nans: bool = True, mp_cores: typing.SupportsInt = 1) -> tuple[list[int], list[int], list[int]]:
    ...
@typing.overload
def find_local_maxima(data: numpy.ndarray[numpy.int64], threshold: typing.SupportsInt | None = None, accept_nans: bool = True, mp_cores: typing.SupportsInt = 1) -> tuple[list[int], list[int]]:
    ...
@typing.overload
def find_local_maxima(data: numpy.ndarray[numpy.int32], threshold: typing.SupportsInt | None = None, accept_nans: bool = True, mp_cores: typing.SupportsInt = 1) -> tuple[list[int], list[int], list[int], list[int]]:
    ...
@typing.overload
def find_local_maxima(data: numpy.ndarray[numpy.int32], threshold: typing.SupportsInt | None = None, accept_nans: bool = True, mp_cores: typing.SupportsInt = 1) -> tuple[list[int], list[int], list[int]]:
    ...
@typing.overload
def find_local_maxima(data: numpy.ndarray[numpy.int32], threshold: typing.SupportsInt | None = None, accept_nans: bool = True, mp_cores: typing.SupportsInt = 1) -> tuple[list[int], list[int]]:
    ...
@typing.overload
def find_local_maxima(data: numpy.ndarray[numpy.int16], threshold: typing.SupportsInt | None = None, accept_nans: bool = True, mp_cores: typing.SupportsInt = 1) -> tuple[list[int], list[int], list[int], list[int]]:
    ...
@typing.overload
def find_local_maxima(data: numpy.ndarray[numpy.int16], threshold: typing.SupportsInt | None = None, accept_nans: bool = True, mp_cores: typing.SupportsInt = 1) -> tuple[list[int], list[int], list[int]]:
    ...
@typing.overload
def find_local_maxima(data: numpy.ndarray[numpy.int16], threshold: typing.SupportsInt | None = None, accept_nans: bool = True, mp_cores: typing.SupportsInt = 1) -> tuple[list[int], list[int]]:
    ...
@typing.overload
def find_local_maxima(data: numpy.ndarray[numpy.int8], threshold: typing.SupportsInt | None = None, accept_nans: bool = True, mp_cores: typing.SupportsInt = 1) -> tuple[list[int], list[int], list[int], list[int]]:
    ...
@typing.overload
def find_local_maxima(data: numpy.ndarray[numpy.int8], threshold: typing.SupportsInt | None = None, accept_nans: bool = True, mp_cores: typing.SupportsInt = 1) -> tuple[list[int], list[int], list[int]]:
    ...
@typing.overload
def find_local_maxima(data: numpy.ndarray[numpy.int8], threshold: typing.SupportsInt | None = None, accept_nans: bool = True, mp_cores: typing.SupportsInt = 1) -> tuple[list[int], list[int]]:
    ...
@typing.overload
def find_local_maxima2(data: numpy.ndarray[numpy.float64], threshold: typing.SupportsFloat | None = None, accept_nans: bool = True, mp_cores: typing.SupportsInt = 1) -> list[numpy.ndarray[numpy.int64]]:
    ...
@typing.overload
def find_local_maxima2(data: numpy.ndarray[numpy.float64], threshold: typing.SupportsFloat | None = None, accept_nans: bool = True, mp_cores: typing.SupportsInt = 1) -> list[numpy.ndarray[numpy.int64]]:
    ...
@typing.overload
def find_local_maxima2(data: numpy.ndarray[numpy.float64], threshold: typing.SupportsFloat | None = None, accept_nans: bool = True, mp_cores: typing.SupportsInt = 1) -> list[int]:
    ...
@typing.overload
def find_local_maxima2(data: numpy.ndarray[numpy.float32], threshold: typing.SupportsFloat | None = None, accept_nans: bool = True, mp_cores: typing.SupportsInt = 1) -> list[numpy.ndarray[numpy.int64]]:
    ...
@typing.overload
def find_local_maxima2(data: numpy.ndarray[numpy.float32], threshold: typing.SupportsFloat | None = None, accept_nans: bool = True, mp_cores: typing.SupportsInt = 1) -> list[numpy.ndarray[numpy.int64]]:
    ...
@typing.overload
def find_local_maxima2(data: numpy.ndarray[numpy.float32], threshold: typing.SupportsFloat | None = None, accept_nans: bool = True, mp_cores: typing.SupportsInt = 1) -> list[int]:
    ...
@typing.overload
def find_local_maxima2(data: numpy.ndarray[numpy.int64], threshold: typing.SupportsInt | None = None, accept_nans: bool = True, mp_cores: typing.SupportsInt = 1) -> list[numpy.ndarray[numpy.int64]]:
    ...
@typing.overload
def find_local_maxima2(data: numpy.ndarray[numpy.int64], threshold: typing.SupportsInt | None = None, accept_nans: bool = True, mp_cores: typing.SupportsInt = 1) -> list[numpy.ndarray[numpy.int64]]:
    ...
@typing.overload
def find_local_maxima2(data: numpy.ndarray[numpy.int64], threshold: typing.SupportsInt | None = None, accept_nans: bool = True, mp_cores: typing.SupportsInt = 1) -> list[int]:
    ...
@typing.overload
def find_local_maxima2(data: numpy.ndarray[numpy.int32], threshold: typing.SupportsInt | None = None, accept_nans: bool = True, mp_cores: typing.SupportsInt = 1) -> list[numpy.ndarray[numpy.int64]]:
    ...
@typing.overload
def find_local_maxima2(data: numpy.ndarray[numpy.int32], threshold: typing.SupportsInt | None = None, accept_nans: bool = True, mp_cores: typing.SupportsInt = 1) -> list[numpy.ndarray[numpy.int64]]:
    ...
@typing.overload
def find_local_maxima2(data: numpy.ndarray[numpy.int32], threshold: typing.SupportsInt | None = None, accept_nans: bool = True, mp_cores: typing.SupportsInt = 1) -> list[int]:
    ...
@typing.overload
def find_local_maxima2(data: numpy.ndarray[numpy.int16], threshold: typing.SupportsInt | None = None, accept_nans: bool = True, mp_cores: typing.SupportsInt = 1) -> list[numpy.ndarray[numpy.int64]]:
    ...
@typing.overload
def find_local_maxima2(data: numpy.ndarray[numpy.int16], threshold: typing.SupportsInt | None = None, accept_nans: bool = True, mp_cores: typing.SupportsInt = 1) -> list[numpy.ndarray[numpy.int64]]:
    ...
@typing.overload
def find_local_maxima2(data: numpy.ndarray[numpy.int16], threshold: typing.SupportsInt | None = None, accept_nans: bool = True, mp_cores: typing.SupportsInt = 1) -> list[int]:
    ...
@typing.overload
def find_local_maxima2(data: numpy.ndarray[numpy.int8], threshold: typing.SupportsInt | None = None, accept_nans: bool = True, mp_cores: typing.SupportsInt = 1) -> list[numpy.ndarray[numpy.int64]]:
    ...
@typing.overload
def find_local_maxima2(data: numpy.ndarray[numpy.int8], threshold: typing.SupportsInt | None = None, accept_nans: bool = True, mp_cores: typing.SupportsInt = 1) -> list[numpy.ndarray[numpy.int64]]:
    ...
@typing.overload
def find_local_maxima2(data: numpy.ndarray[numpy.int8], threshold: typing.SupportsInt | None = None, accept_nans: bool = True, mp_cores: typing.SupportsInt = 1) -> list[int]:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int64], data_volume: numpy.ndarray[numpy.float64], null_region: typing.SupportsInt = 0, threshold: typing.SupportsFloat | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int64], data_volume: numpy.ndarray[numpy.float64], null_region: typing.SupportsInt = 0, threshold: typing.SupportsFloat | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int64], data_volume: numpy.ndarray[numpy.float64], null_region: typing.SupportsInt = 0, threshold: typing.SupportsFloat | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int32], data_volume: numpy.ndarray[numpy.float64], null_region: typing.SupportsInt = 0, threshold: typing.SupportsFloat | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int32], data_volume: numpy.ndarray[numpy.float64], null_region: typing.SupportsInt = 0, threshold: typing.SupportsFloat | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int32], data_volume: numpy.ndarray[numpy.float64], null_region: typing.SupportsInt = 0, threshold: typing.SupportsFloat | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int16], data_volume: numpy.ndarray[numpy.float64], null_region: typing.SupportsInt = 0, threshold: typing.SupportsFloat | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int16], data_volume: numpy.ndarray[numpy.float64], null_region: typing.SupportsInt = 0, threshold: typing.SupportsFloat | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int16], data_volume: numpy.ndarray[numpy.float64], null_region: typing.SupportsInt = 0, threshold: typing.SupportsFloat | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int8], data_volume: numpy.ndarray[numpy.float64], null_region: typing.SupportsInt = 0, threshold: typing.SupportsFloat | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int8], data_volume: numpy.ndarray[numpy.float64], null_region: typing.SupportsInt = 0, threshold: typing.SupportsFloat | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int8], data_volume: numpy.ndarray[numpy.float64], null_region: typing.SupportsInt = 0, threshold: typing.SupportsFloat | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int64], data_volume: numpy.ndarray[numpy.float32], null_region: typing.SupportsInt = 0, threshold: typing.SupportsFloat | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int64], data_volume: numpy.ndarray[numpy.float32], null_region: typing.SupportsInt = 0, threshold: typing.SupportsFloat | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int64], data_volume: numpy.ndarray[numpy.float32], null_region: typing.SupportsInt = 0, threshold: typing.SupportsFloat | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int32], data_volume: numpy.ndarray[numpy.float32], null_region: typing.SupportsInt = 0, threshold: typing.SupportsFloat | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int32], data_volume: numpy.ndarray[numpy.float32], null_region: typing.SupportsInt = 0, threshold: typing.SupportsFloat | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int32], data_volume: numpy.ndarray[numpy.float32], null_region: typing.SupportsInt = 0, threshold: typing.SupportsFloat | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int16], data_volume: numpy.ndarray[numpy.float32], null_region: typing.SupportsInt = 0, threshold: typing.SupportsFloat | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int16], data_volume: numpy.ndarray[numpy.float32], null_region: typing.SupportsInt = 0, threshold: typing.SupportsFloat | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int16], data_volume: numpy.ndarray[numpy.float32], null_region: typing.SupportsInt = 0, threshold: typing.SupportsFloat | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int8], data_volume: numpy.ndarray[numpy.float32], null_region: typing.SupportsInt = 0, threshold: typing.SupportsFloat | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int8], data_volume: numpy.ndarray[numpy.float32], null_region: typing.SupportsInt = 0, threshold: typing.SupportsFloat | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int8], data_volume: numpy.ndarray[numpy.float32], null_region: typing.SupportsInt = 0, threshold: typing.SupportsFloat | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int64], data_volume: numpy.ndarray[numpy.int64], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int64], data_volume: numpy.ndarray[numpy.int64], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int64], data_volume: numpy.ndarray[numpy.int64], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int32], data_volume: numpy.ndarray[numpy.int64], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int32], data_volume: numpy.ndarray[numpy.int64], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int32], data_volume: numpy.ndarray[numpy.int64], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int16], data_volume: numpy.ndarray[numpy.int64], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int16], data_volume: numpy.ndarray[numpy.int64], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int16], data_volume: numpy.ndarray[numpy.int64], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int8], data_volume: numpy.ndarray[numpy.int64], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int8], data_volume: numpy.ndarray[numpy.int64], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int8], data_volume: numpy.ndarray[numpy.int64], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int64], data_volume: numpy.ndarray[numpy.int32], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int64], data_volume: numpy.ndarray[numpy.int32], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int64], data_volume: numpy.ndarray[numpy.int32], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int32], data_volume: numpy.ndarray[numpy.int32], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int32], data_volume: numpy.ndarray[numpy.int32], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int32], data_volume: numpy.ndarray[numpy.int32], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int16], data_volume: numpy.ndarray[numpy.int32], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int16], data_volume: numpy.ndarray[numpy.int32], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int16], data_volume: numpy.ndarray[numpy.int32], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int8], data_volume: numpy.ndarray[numpy.int32], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int8], data_volume: numpy.ndarray[numpy.int32], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int8], data_volume: numpy.ndarray[numpy.int32], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int64], data_volume: numpy.ndarray[numpy.int16], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int64], data_volume: numpy.ndarray[numpy.int16], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int64], data_volume: numpy.ndarray[numpy.int16], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int32], data_volume: numpy.ndarray[numpy.int16], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int32], data_volume: numpy.ndarray[numpy.int16], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int32], data_volume: numpy.ndarray[numpy.int16], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int16], data_volume: numpy.ndarray[numpy.int16], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int16], data_volume: numpy.ndarray[numpy.int16], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int16], data_volume: numpy.ndarray[numpy.int16], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int8], data_volume: numpy.ndarray[numpy.int16], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int8], data_volume: numpy.ndarray[numpy.int16], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int8], data_volume: numpy.ndarray[numpy.int16], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int64], data_volume: numpy.ndarray[numpy.int8], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int64], data_volume: numpy.ndarray[numpy.int8], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int64], data_volume: numpy.ndarray[numpy.int8], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int32], data_volume: numpy.ndarray[numpy.int8], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int32], data_volume: numpy.ndarray[numpy.int8], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int32], data_volume: numpy.ndarray[numpy.int8], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int16], data_volume: numpy.ndarray[numpy.int8], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int16], data_volume: numpy.ndarray[numpy.int8], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int16], data_volume: numpy.ndarray[numpy.int8], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int8], data_volume: numpy.ndarray[numpy.int8], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int8], data_volume: numpy.ndarray[numpy.int8], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
@typing.overload
def grow_regions(region_volume: numpy.ndarray[numpy.int8], data_volume: numpy.ndarray[numpy.int8], null_region: typing.SupportsInt = 0, threshold: typing.SupportsInt | None = None, force_negative_gradient: bool = True, eat_neighbor_regions: bool = False, mp_cores: typing.SupportsInt = 1) -> bool:
    ...
